// Copyright 2024-2026 Alişah Özcan
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
// Developer: Alişah Özcan

#ifndef HEONGPU_CKKS_MPC_MANAGER_H
#define HEONGPU_CKKS_MPC_MANAGER_H

#include "gpuntt/ntt_merge/ntt.cuh"
#include <heongpu/kernel/addition.cuh>
#include <heongpu/kernel/switchkey.cuh>
#include <heongpu/kernel/encryption.cuh>
#include <heongpu/kernel/decryption.cuh>
#include <heongpu/host/ckks/context.cuh>
#include <heongpu/host/ckks/secretkey.cuh>
#include <heongpu/host/ckks/publickey.cuh>
#include <heongpu/host/ckks/evaluationkey.cuh>
#include <heongpu/host/ckks/encoder.cuh>
#include <heongpu/host/ckks/ciphertext.cuh>

namespace heongpu
{
    /**
     * @class HEMultiPartyManager<Scheme::BFV>
     * @brief High-level controller for all multi-party CKKS protocols
     * based on 'https://eprint.iacr.org/2020/304.pdf' and
     * 'https://arxiv.org/pdf/2009.00349' papers.
     *
     *  • establish joint public, relinearization and Galois keys without
     *    exposing their private secrets
     *  • refresh ciphertexts through _distributed bootstrapping_
     *  • perform threshold or collective decryption by fusing partial shares
     */
    template <> class HEMultiPartyManager<Scheme::CKKS>
    {
      public:
        /**
         * @brief Constructs a new HEMultiPartyManager object with specified
         * parameters.
         *
         * @param context Reference to the Parameters object that sets the
         * encryption parameters.
         */
        __host__ HEMultiPartyManager(HEContext<Scheme::CKKS> context,
                                     HEEncoder<Scheme::CKKS>& encoder,
                                     double& scale);

        /**
         * @brief Generates a partial public key for multiparty computation
         * (Each participant).
         *
         * Each participant generates a partial public key piece using their
         * secret key. These partial public keys will later be combined to form
         * the final public key.
         *
         * @param pk Reference to the MultipartyPublickey object where the
         * generated partial public key will be stored.
         * @param sk The Secretkey of the participant generating the partial
         * public key.
         */
        __host__ void generate_public_key_share(
            MultipartyPublickey<Scheme::CKKS>& pk, Secretkey<Scheme::CKKS>& sk,
            const ExecutionOptions& options = ExecutionOptions())
        {
            if (!sk.secret_key_generated_)
            {
                throw std::logic_error("Secretkey is not generated!");
            }

            if (pk.public_key_generated_)
            {
                throw std::logic_error("Publickey is already generated!");
            }

            input_storage_manager(
                sk,
                [&](Secretkey<Scheme::CKKS>& sk_)
                {
                    output_storage_manager(
                        pk,
                        [&](MultipartyPublickey<Scheme::CKKS>& pk_)
                        {
                            generate_public_key_stage1(pk_, sk_,
                                                       options.stream_);

                            pk_.in_ntt_domain_ = true;
                            pk_.public_key_generated_ = true;
                        },
                        options);
                },
                options, false);
        }

        /**
         * @brief Assemble partial public keys from all participants into a
         * final public key (Collective).
         *
         * This function aggregates all partial public keys generated by the
         * participants into a single final public key for use in multiparty
         * computations.
         *
         * @param all_pk Vector containing the partial public keys from all
         * participants.
         * @param pk Reference to the Publickey object where the combined final
         * public key will be stored.
         */
        __host__ void assemble_public_key_share(
            std::vector<MultipartyPublickey<Scheme::CKKS>>& all_pk,
            Publickey<Scheme::CKKS>& pk,
            const ExecutionOptions& options = ExecutionOptions())
        {
            int participant_count = all_pk.size();

            if (participant_count == 0)
            {
                throw std::invalid_argument(
                    "No participant to generate common publickey!");
            }

            for (int i = 0; i < participant_count; i++)
            {
                if (!all_pk[i].public_key_generated_)
                {
                    throw std::invalid_argument(
                        "MultipartyPublickey is not generated!");
                }
            }

            input_vector_storage_manager(
                all_pk,
                [&](std::vector<MultipartyPublickey<Scheme::CKKS>>& all_pk_)
                {
                    output_storage_manager(
                        pk,
                        [&](Publickey<Scheme::CKKS>& pk_)
                        {
                            generate_public_key_stage2(all_pk_, pk_,
                                                       options.stream_);
                            pk_.in_ntt_domain_ = true;
                            pk_.public_key_generated_ = true;
                        },
                        options);
                },
                options, false);
        }

        /**
         * @brief Generates a partial relinearization key piece for multiparty
         * computation (Stage 1 - Each).
         *
         * Each party generates its own partial relinearization key piece using
         * their secret key. The process depends on the specified key switching
         * method and scheme type BFV.
         *
         * @param rk Reference to the MultipartyRelinkey object that will store
         * the generated key piece.
         * @param sk The Secretkey of the participant generating the partial
         * relinearization key.
         */
        __host__ void generate_relin_key_init(
            MultipartyRelinkey<Scheme::CKKS>& rk, Secretkey<Scheme::CKKS>& sk,
            const ExecutionOptions& options = ExecutionOptions())
        {
            switch (static_cast<int>(rk.key_type))
            {
                case 1: // KEYSWITCHING_METHOD_I
                    generate_relin_key_method_I_stage_1(rk, sk, options);
                    break;
                case 2: // KEYSWITCHING_METHOD_II
                    generate_ckks_relin_key_method_II_stage_1(rk, sk, options);
                    break;
                case 3: // KEYSWITCHING_METHOD_III
                    throw std::invalid_argument(
                        "Key Switching Type III is not supported for multi "
                        "party key generation.");
                    break;
                default:
                    throw std::invalid_argument("Invalid Key Switching Type");
                    break;
            }
        }

        /**
         * @brief Generates a partial relinearization key piece for multiparty
         * computation (Stage 2 - Each).
         *
         * This function processes the partial relinearization key pieces from
         * Stage 1 to produce updated key pieces. It verifies the compatibility
         * of the input relinearization key parameters.
         *
         * @param rk_s1_common Reference to the shared Stage 1 relinearization
         * key.
         * @param rk_new Reference to the MultipartyRelinkey object for storing
         * the new key piece.
         * @param sk The Secretkey of the participant generating the updated
         * relinearization key piece.
         */
        __host__ void generate_relin_key_share(
            MultipartyRelinkey<Scheme::CKKS>& rk_s1_common,
            MultipartyRelinkey<Scheme::CKKS>& rk_new,
            Secretkey<Scheme::CKKS>& sk,
            const ExecutionOptions& options = ExecutionOptions())
        {
            if ((rk_s1_common.scheme_ != rk_new.scheme_) ||
                (rk_s1_common.key_type != rk_new.key_type))
            {
                throw std::invalid_argument("Invalid relinkey parameters!");
            }

            switch (static_cast<int>(rk_s1_common.key_type))
            {
                case 1: // KEYSWITCHING_METHOD_I
                    generate_relin_key_method_I_stage_3(rk_s1_common, rk_new,
                                                        sk, options);
                    break;
                case 2: // KEYSWITCHING_METHOD_II
                    generate_ckks_relin_key_method_II_stage_3(
                        rk_s1_common, rk_new, sk, options);
                    break;
                case 3: // KEYSWITCHING_METHOD_III
                    throw std::invalid_argument(
                        "Key Switching Type III is not supported for multi "
                        "party key generation.");
                    break;
                default:
                    throw std::invalid_argument("Invalid Key Switching Type");
                    break;
            }
        }

        /**
         * @brief Assemble partial relinearization keys from all participants
         * (Stage 1 - Collective).
         *
         * This function aggregates all partial relinearization key pieces from
         * multiple participants into a single collective relinearization key
         * for Stage 1.
         *
         * @param all_rk Vector containing partial relinearization keys from all
         * participants.
         * @param rk Reference to the MultipartyRelinkey object for storing the
         * aggregated key.
         */
        __host__ void assemble_relin_key_init(
            std::vector<MultipartyRelinkey<Scheme::CKKS>>& all_rk,
            MultipartyRelinkey<Scheme::CKKS>& rk,
            const ExecutionOptions& options = ExecutionOptions())
        {
            generate_relin_key_stage_2(all_rk, rk, options);
        }

        /**
         * @brief Assemble partial relinearization keys from all participants
         * (Stage 2 - Collective).
         *
         * In Stage 2, this function aggregates updated relinearization key
         * pieces from multiple participants into a single collective
         * relinearization key.
         *
         * @param all_rk Vector containing updated relinearization keys from all
         * participants.
         * @param rk_common_stage1 Reference to the shared Stage 1 collective
         * relinearization key.
         * @param rk Reference to the final Relinkey object that will store the
         * aggregated key.
         */
        __host__ void assemble_relin_key_share(
            std::vector<MultipartyRelinkey<Scheme::CKKS>>& all_rk,
            MultipartyRelinkey<Scheme::CKKS>& rk_common_stage1,
            Relinkey<Scheme::CKKS>& rk,
            const ExecutionOptions& options = ExecutionOptions())
        {
            generate_relin_key_stage_4(all_rk, rk_common_stage1, rk, options);
        }

        /**
         * @brief Generates a Galois key using a secret key.
         *
         * @param gk Reference to the Galoiskey object where the generated
         * Galois key will be stored.
         * @param sk Reference to the Secretkey object used to generate the
         * Galois key.
         */
        __host__ void generate_galois_key_share(
            MultipartyGaloiskey<Scheme::CKKS>& gk, Secretkey<Scheme::CKKS>& sk,
            const ExecutionOptions& options = ExecutionOptions())
        {
            switch (static_cast<int>(gk.key_type))
            {
                case 1: // KEYSWITCHING_METHOD_I
                    generate_galois_key_method_I_stage_1(gk, sk, options);
                    break;
                case 2: // KEYSWITCHING_METHOD_II
                    generate_galois_key_method_II_stage_1(gk, sk, options);
                    break;
                case 3: // KEYSWITCHING_METHOD_III
                    throw std::invalid_argument(
                        "Key Switching Type III is not supported for multi "
                        "party key generation.");
                    break;
                default:
                    throw std::invalid_argument("Invalid Key Switching Type");
                    break;
            }
        }

        /**
         * @brief Generates a partial Galois key for multiparty computation
         * (Each participant).
         *
         * Each participant generates a partial Galois key piece using their
         * secret key. The generated key piece is scheme-dependent BFV
         * and follows the specified key switching method.
         *
         * @param gk Reference to the MultipartyGaloiskey object where the
         * generated partial Galois key will be stored.
         * @param sk The Secretkey of the participant generating the partial
         * Galois key.
         * @throws std::invalid_argument If an unsupported key switching type or
         * scheme is specified.
         */
        __host__ void assemble_galois_key_share(
            std::vector<MultipartyGaloiskey<Scheme::CKKS>>& all_gk,
            Galoiskey<Scheme::CKKS>& gk,
            const ExecutionOptions& options = ExecutionOptions())
        {
            generate_galois_key_stage_2(all_gk, gk, options);
        }

        /**
         * @brief Performs a partial decryption of a ciphertext using a secret
         * key.
         *
         * This method is used in multiparty decryption scenarios where each
         * party partially decrypts the ciphertext with their own secret key.
         * The resulting partially decrypted ciphertext is stored for later
         * fusion.
         *
         * @param ciphertext The ciphertext to be partially decrypted.
         * @param sk The secret key of the party performing the partial
         * decryption.
         * @param partial_ciphertext The output ciphertext containing the
         * partially decrypted data.
         */
        __host__ void
        decrypt_partial(Ciphertext<Scheme::CKKS>& ciphertext,
                        Secretkey<Scheme::CKKS>& sk,
                        Ciphertext<Scheme::CKKS>& partial_ciphertext,
                        const ExecutionOptions& options = ExecutionOptions())
        {
            partial_decrypt_stage_1(ciphertext, sk, partial_ciphertext,
                                    options.stream_);

            partial_ciphertext.scheme_ = context_->scheme_;
            partial_ciphertext.ring_size_ = context_->n;
            partial_ciphertext.coeff_modulus_count_ = context_->Q_size;
            partial_ciphertext.cipher_size_ = 2;
            partial_ciphertext.depth_ = ciphertext.depth_;
            partial_ciphertext.in_ntt_domain_ = ciphertext.in_ntt_domain_;
            partial_ciphertext.scale_ = ciphertext.scale_;
            partial_ciphertext.rescale_required_ = ciphertext.rescale_required_;
            partial_ciphertext.relinearization_required_ =
                ciphertext.relinearization_required_;
        }

        /**
         * @brief Fuses partially decrypted ciphertexts into a fully decrypted
         * plaintext.
         *
         * In multiparty decryption, each participant generates a partial
         * decryption of the ciphertext. This method combines those partial
         * decryptions to produce the final plaintext output.
         *
         * @param ciphertexts A vector containing partially decrypted
         * ciphertexts from multiple parties.
         * @param plaintext The output plaintext resulting from the fusion of
         * all partial decryptions.
         */
        __host__ void
        decrypt(std::vector<Ciphertext<Scheme::CKKS>>& ciphertexts,
                Plaintext<Scheme::CKKS>& plaintext,
                const ExecutionOptions& options = ExecutionOptions())
        {
            int cipher_count = ciphertexts.size();

            if (cipher_count == 0)
            {
                throw std::invalid_argument("No ciphertext to decrypt!");
            }

            scheme_type scheme_check = ciphertexts[0].scheme_;
            int depth_check = ciphertexts[0].depth_;
            double scale_check = ciphertexts[0].scale_;

            for (int i = 1; i < cipher_count; i++)
            {
                if (scheme_check != ciphertexts[i].scheme_)
                {
                    throw std::invalid_argument(
                        "Ciphertext schemes should be same!");
                }

                if (depth_check != ciphertexts[i].depth_)
                {
                    throw std::invalid_argument(
                        "Ciphertext levels should be same!");
                }

                if (scale_check != ciphertexts[i].scale_)
                {
                    throw std::invalid_argument(
                        "Ciphertext scales should be same!");
                }
            }

            input_vector_storage_manager(
                ciphertexts,
                [&](std::vector<Ciphertext<Scheme::CKKS>>& ciphertexts_)
                {
                    output_storage_manager(
                        plaintext,
                        [&](Plaintext<Scheme::CKKS>& plaintext_)
                        {
                            partial_decrypt_stage_2(ciphertexts_, plaintext_,
                                                    options.stream_);

                            plaintext_.plain_size_ =
                                context_->n * context_->Q_size;
                            plaintext_.scheme_ = context_->scheme_;
                            plaintext_.depth_ = depth_check;
                            plaintext_.scale_ = scale_check;
                            plaintext_.in_ntt_domain_ = true;
                        },
                        options);
                },
                options, false);
        }

        /**
         * @brief Generates a participant’s encrypted share for distributed
         * bootstrapping.
         *
         * In a distributed-bootstrapping protocol, every party refreshes the
         * *same* noisy ciphertext without ever revealing its own secret key.
         * Each participant takes the shared input (`common`), uses its
         * `secret_key` to compute a *partial bootstrapping share*, and writes
         * the result to `output`.  These shares will later be aggregated by the
         * coordinator to obtain a fully refreshed ciphertext.
         *
         * @param common       The common ciphertext that all parties are
         * jointly bootstrapping (read-only for the participant).
         * @param output       The ciphertext that will hold this participant’s
         *                     encrypted share after processing.
         * @param secret_key   The participant’s secret key used to generate the
         *                     share.
         * @param seed         Common seed material for the RNG.
         */
        __host__ void distributed_bootstrapping_participant(
            Ciphertext<Scheme::CKKS>& common, Ciphertext<Scheme::CKKS>& output,
            Secretkey<Scheme::CKKS>& secret_key, const RNGSeed& seed,
            const ExecutionOptions& options = ExecutionOptions())
        {
            input_storage_manager(
                common,
                [&](Ciphertext<Scheme::CKKS>& common_)
                {
                    input_storage_manager(
                        secret_key,
                        [&](Secretkey<Scheme::CKKS>& secret_key_)
                        {
                            output_storage_manager(
                                output,
                                [&](Ciphertext<Scheme::CKKS>& output_)
                                {
                                    distributed_bootstrapping_stage1(
                                        common_, output_, secret_key_, seed,
                                        options.stream_);

                                    output.scheme_ = context_->scheme_;
                                    output.ring_size_ = context_->n;
                                    output.coeff_modulus_count_ =
                                        context_->Q_size;
                                    output.cipher_size_ = 2;
                                    output.depth_ = common.depth_;
                                    output.in_ntt_domain_ = true;
                                    output.scale_ = common.scale_;
                                    output.rescale_required_ = false;
                                    output.relinearization_required_ = false;
                                    output.ciphertext_generated_ = true;
                                },
                                options);
                        },
                        options, false);
                },
                options, (&common == &output));
        }

        /**
         * @brief Aggregates participant shares to create a fully bootstrapped
         * ciphertext.
         *
         * After every participant has produced an encrypted share with
         * `distributed_bootstrapping_participant`, the coordinator collects all
         * shares in `ciphertexts` and fuses them—together with the (possibly
         * updated) auxiliary ciphertext `common`—into the final, low-noise
         * ciphertext `output`.  The resulting ciphertext is functionally
         * equivalent to the original but has its noise budget fully restored,
         * enabling further homomorphic computation.
         *
         * @param ciphertexts  Vector of encrypted shares produced by all
         *                     participants.
         * @param common       The auxiliary ciphertext that is shared across
         * the protocol rounds; it may be updated in place.
         * @param output       The fully bootstrapped ciphertext produced by
         *                     combining all shares.
         * @param seed         Common seed material for the RNG.
         */
        __host__ void distributed_bootstrapping_coordinator(
            std::vector<Ciphertext<Scheme::CKKS>>& ciphertexts,
            Ciphertext<Scheme::CKKS>& common, Ciphertext<Scheme::CKKS>& output,
            const RNGSeed& seed,
            const ExecutionOptions& options = ExecutionOptions())
        {
            input_vector_storage_manager(
                ciphertexts,
                [&](std::vector<Ciphertext<Scheme::CKKS>>& ciphertexts_)
                {
                    input_storage_manager(
                        common,
                        [&](Ciphertext<Scheme::CKKS>& common_)
                        {
                            output_storage_manager(
                                output,
                                [&](Ciphertext<Scheme::CKKS>& output_)
                                {
                                    distributed_bootstrapping_stage2(
                                        ciphertexts_, common_, output_, seed,
                                        options.stream_);

                                    output.scheme_ = context_->scheme_;
                                    output.ring_size_ = context_->n;
                                    output.coeff_modulus_count_ =
                                        context_->Q_size;
                                    output.cipher_size_ = 2;
                                    output.depth_ = 0;
                                    output.in_ntt_domain_ = true;
                                    output.scale_ = scale_;
                                    output.rescale_required_ = false;
                                    output.relinearization_required_ = false;
                                    output.ciphertext_generated_ = true;
                                },
                                options);
                        },
                        options, (&common == &output));
                },
                options, false);
        }

        HEMultiPartyManager() = default;
        HEMultiPartyManager(const HEMultiPartyManager& copy) = default;
        HEMultiPartyManager(HEMultiPartyManager&& source) = default;
        HEMultiPartyManager&
        operator=(const HEMultiPartyManager& assign) = default;
        HEMultiPartyManager& operator=(HEMultiPartyManager&& assign) = default;

      private:
        __host__ void
        generate_public_key_stage1(MultipartyPublickey<Scheme::CKKS>& pk,
                                   Secretkey<Scheme::CKKS>& sk,
                                   const cudaStream_t stream);

        __host__ void generate_public_key_stage2(
            std::vector<MultipartyPublickey<Scheme::CKKS>>& all_pk,
            Publickey<Scheme::CKKS>& pk, const cudaStream_t stream);

        __host__ void generate_relin_key_method_I_stage_1(
            MultipartyRelinkey<Scheme::CKKS>& rk, Secretkey<Scheme::CKKS>& sk,
            const ExecutionOptions& options);

        __host__ void generate_relin_key_method_I_stage_3(
            MultipartyRelinkey<Scheme::CKKS>& rk_stage_1,
            MultipartyRelinkey<Scheme::CKKS>& rk_stage_2,
            Secretkey<Scheme::CKKS>& sk, const ExecutionOptions& options);

        __host__ void generate_ckks_relin_key_method_II_stage_1(
            MultipartyRelinkey<Scheme::CKKS>& rk, Secretkey<Scheme::CKKS>& sk,
            const ExecutionOptions& options);

        __host__ void generate_ckks_relin_key_method_II_stage_3(
            MultipartyRelinkey<Scheme::CKKS>& rk_stage_1,
            MultipartyRelinkey<Scheme::CKKS>& rk_stage_2,
            Secretkey<Scheme::CKKS>& sk, const ExecutionOptions& options);

        __host__ void generate_relin_key_stage_2(
            std::vector<MultipartyRelinkey<Scheme::CKKS>>& all_rk,
            MultipartyRelinkey<Scheme::CKKS>& rk,
            const ExecutionOptions& options);

        __host__ void generate_relin_key_stage_4(
            std::vector<MultipartyRelinkey<Scheme::CKKS>>& all_rk,
            MultipartyRelinkey<Scheme::CKKS>& rk_common_stage1,
            Relinkey<Scheme::CKKS>& rk, const ExecutionOptions& options);

        __host__ void generate_galois_key_method_I_stage_1(
            MultipartyGaloiskey<Scheme::CKKS>& gk, Secretkey<Scheme::CKKS>& sk,
            const ExecutionOptions& options);

        __host__ void generate_galois_key_method_II_stage_1(
            MultipartyGaloiskey<Scheme::CKKS>& gk, Secretkey<Scheme::CKKS>& sk,
            const ExecutionOptions& options);

        __host__ void generate_galois_key_stage_2(
            std::vector<MultipartyGaloiskey<Scheme::CKKS>>& all_gk,
            Galoiskey<Scheme::CKKS>& gk, const ExecutionOptions& options);

        __host__ void
        partial_decrypt_stage_1(Ciphertext<Scheme::CKKS>& ciphertext,
                                Secretkey<Scheme::CKKS>& sk,
                                Ciphertext<Scheme::CKKS>& partial_ciphertext,
                                const cudaStream_t stream);

        __host__ void partial_decrypt_stage_2(
            std::vector<Ciphertext<Scheme::CKKS>>& ciphertexts,
            Plaintext<Scheme::CKKS>& plaintext, const cudaStream_t stream);

        __host__ void distributed_bootstrapping_stage1(
            Ciphertext<Scheme::CKKS>& common, Ciphertext<Scheme::CKKS>& output,
            Secretkey<Scheme::CKKS>& secret_key, const RNGSeed& seed,
            const cudaStream_t stream);

        __host__ void distributed_bootstrapping_stage2(
            std::vector<Ciphertext<Scheme::CKKS>>& ciphertexts,
            Ciphertext<Scheme::CKKS>& common, Ciphertext<Scheme::CKKS>& output,
            const RNGSeed& seed, const cudaStream_t stream);

      private:
        HEContext<Scheme::CKKS> context_;
        int slot_count_;

        double scale_;
        double two_pow_64;
        int log_slot_count_;
        int fft_length;
        Complex64 special_root;

        std::shared_ptr<DeviceVector<Complex64>> special_fft_roots_table_;
        std::shared_ptr<DeviceVector<Complex64>> special_ifft_roots_table_;
        std::shared_ptr<DeviceVector<int>> reverse_order;

        std::mt19937 engine_;
        std::normal_distribution<double> distribution_;
        RNGSeed new_seed_;
    };

} // namespace heongpu
#endif // HEONGPU_CKKS_MPC_MANAGER_H
